import tkinter as tk
from tkinter import ttk, messagebox, filedialog
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import numpy as np
from scipy.fft import fft
import re

# --- GLOBAL CONFIGURATION ---
LFSR_WIDTH = 16
# Base period used for ordinary PWM comparison and sequence length context
PWM_BASE_PERIOD = 255
# Shorter length for quickly calculating all 256 error points in the plot
ERROR_CALC_LENGTH = 512
# Fixed visual cap for the Time Domain plot (to keep the waveform legible)
VISUAL_SEGMENT_CAP = 512

# RC Filter Time Constant (Alpha) for the simulated integrator
RC_FILTER_ALPHA = 0.1

# Global variable to store parsed data
parsed_lfsr_config = []

# --- PARSING FUNCTION (REMOVED COMMENT DEPENDENCY) ---
def parse_c_code(c_code_content):
    """
    Parses the C array content to extract mask and seed.

    The PWM Level is determined by the array index (position). No data is
    extracted from comments, as requested.

    Expected match pattern: { 0xMASKu, 0xSEEDu },
    """
    global parsed_lfsr_config
    parsed_lfsr_config = []

    # Regex captures only 0xMASK and 0xSEED, ignoring all text (including comments) after the array entry.
    pattern = re.compile(
        r"\{\s*(0x[0-9a-fA-F]+)(?:u)?\s*,\s*(0x[0-9a-fA-F]+)(?:u)?\s*\}\s*,?",
        re.MULTILINE | re.DOTALL
    )

    # We find all (mask_str, seed_str) tuples
    matches = pattern.findall(c_code_content)

    if not matches:
        return False

    # The level (0-255) is explicitly determined by the index 'i'
    for i, (mask_str, seed_str) in enumerate(matches):
        try:
            mask = int(mask_str, 16)
            seed = int(seed_str, 16)

            parsed_lfsr_config.append({
                'mask': mask,
                'seed': seed,
                'period': PWM_BASE_PERIOD,
            })
        except ValueError as e:
            print(f"Skipping malformed entry at index {i}: {mask_str}, {seed_str}. Error: {e}")
            continue

    # The LUT should ideally have 256 entries for levels 0-255
    return len(parsed_lfsr_config) == 256

# --- LFSR CORE FUNCTION (SEED > THRESHOLD) ---

def run_lfsr_sequence(mask, seed, sequence_len, width=16):
    """
    Runs a deterministic LFSR using a Fibonacci structure where the PWM output
    is generated by comparing the LFSR state against the seed (which also acts
    as the threshold).
    """
    state = seed
    threshold = seed
    signal = []

    def popcount_parity(n):
        """Calculates parity based on the number of set bits."""
        return bin(n).count('1') % 2

    for _ in range(sequence_len):
        # 1. Determine PWM output: HIGH if state > threshold
        if state > threshold:
            signal.append(1)
        else:
            signal.append(0)

        # 2. Advance LFSR state (Fibonacci LFSR with parity feedback)
        feedback = popcount_parity(state & mask)
        state = (state >> 1) | (feedback << (width - 1))

    return np.array(signal, dtype=int)


# --- RC INTEGRATOR SIMULATION (Unchanged) ---

def simulate_rc_integrator(signal, alpha):
    """
    Simulates a first-order RC low-pass filter (integrator).
    """
    if signal.size == 0:
        return np.array([])

    filtered_signal = np.zeros_like(signal, dtype=float)
    beta = 1.0 - alpha
    current_state = 0.0

    for k in range(signal.size):
        current_state = alpha * signal[k] + beta * current_state
        filtered_signal[k] = current_state

    return filtered_signal

# --- SIMULATION FUNCTIONS (Simplified return) ---

def generate_lfsr_pwm_signal(level, sequence_len):
    """
    Generates a deterministic LFSR PWM signal and calculates its actual ratio and error.
    """
    if not (0 <= level <= 255) or not parsed_lfsr_config or level >= len(parsed_lfsr_config):
        # Only return signal, calc_ratio, calc_error
        return np.array([]), 0.0, 0.0

    entry = parsed_lfsr_config[level]
    mask = entry['mask']
    seed = entry['seed']

    # --- Generate the deterministic LFSR sequence ---
    # The LFSR implementation now uses the self-healing logic
    lfsr_signal = run_lfsr_sequence(mask, seed, sequence_len)

    # --- Calculate Actual Ratio and Error from the generated signal ---

    # 1. Calculated Duty Cycle (Ratio)
    calc_ratio = np.mean(lfsr_signal)

    # 2. Ideal Duty Cycle
    D_ideal = level / 255.0

    # 3. Calculated Quantization Error (LFSR Duty Cycle vs Ideal)
    calc_error = calc_ratio - D_ideal

    return lfsr_signal, calc_ratio, calc_error

def calculate_spectral_response(signal, sampling_rate=1.0):
    """Calculates the power spectral density (PSD) using FFT."""
    if signal.size == 0:
        return np.array([]), np.array([])

    N = signal.size
    signal_centered = signal - np.mean(signal)

    yf = fft(signal_centered)

    psd = np.abs(yf[:N//2])**2
    xf = np.linspace(0.0, sampling_rate/2.0, N//2)
    psd_linear = psd / N

    return xf, psd_linear

def generate_ordinary_pwm_signal(level, period, sequence_len):
    """
    Generates an ordinary, counter-based (DPWM) signal for baseline comparison.
    """
    if not (0 <= level <= 255):
        return np.array([])

    D_ideal = level / 255.0
    if period <= 0: period = 1

    on_steps = int(round(D_ideal * period))
    off_steps = period - on_steps

    ordinary_signal = np.concatenate((np.ones(on_steps, dtype=int), np.zeros(off_steps, dtype=int)))

    num_cycles = int(np.ceil(sequence_len / period))
    signal_full = np.tile(ordinary_signal, num_cycles)[:sequence_len]

    return signal_full

# --- TKINTER GUI CLASS (Modified to remove reference error display) ---
class PWM_Analyzer_App:
    def __init__(self, master):
        self.master = master
        master.title("LFSR PWM Look-Up Table Analyzer")
        master.geometry("1200x800")

        self.master.protocol("WM_DELETE_WINDOW", self.on_closing)

        # New variable for controlling the sequence length exponent (2^N)
        # Default to 13 (8192) - Range 9 (512) to 13 (8192)
        self.seq_len_exp_var = tk.IntVar(value=13)

        self.setup_parsing_ui()

    def on_closing(self):
        """Handle cleanup when the main window is closed."""
        try:
            if hasattr(self, 'fig'):
                plt.close(self.fig)
        except Exception:
            pass
        self.master.destroy()

    def setup_parsing_ui(self):
        """Sets up the initial UI to select the C code file."""
        for widget in self.master.winfo_children():
            widget.destroy()

        parse_frame = ttk.Frame(self.master, padding="20")
        parse_frame.pack(fill=tk.BOTH, expand=True)

        ttk.Label(parse_frame, text="16-bit LFSR PWM Analysis Tool",
                  font=('Arial', 14, 'bold')).pack(pady=10)
        ttk.Label(parse_frame, text="Select the C header file (.h) containing the LFSR PWM Look-Up Table:",
                  font=('Arial', 10)).pack(pady=15)
        ttk.Label(parse_frame, text="NOTE: Analysis is now based purely on calculated performance vs. ideal duty cycle, ignoring data in comments.",
                  font=('Arial', 10, 'italic'), foreground='blue').pack(pady=5)


        # UI: Button to open file dialog
        ttk.Button(parse_frame, text="Browse and Load LUT File", command=self.load_file_and_process).pack(pady=10)

        # Label to show the selected file path
        self.filename_label_var = tk.StringVar(value="No file selected.")
        ttk.Label(parse_frame, textvariable=self.filename_label_var, foreground="blue").pack(pady=5)

    def load_file_and_process(self):
        """Opens a file dialog, reads the selected file, and processes its content."""

        file_path = filedialog.askopenfilename(
            defaultextension=".h",
            filetypes=[
                ("C Header Files (LUT)", "*.h"),
                ("C Source Files", "*.c"),
                ("All Files", "*.*")
            ],
            title="Select LFSR PWM Look-Up Table File"
        )

        if not file_path:
            self.filename_label_var.set("File selection cancelled.")
            return

        self.filename_label_var.set(f"Selected: {file_path}")

        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                c_code_content = f.read()

            # Attempt to parse the code
            if parse_c_code(c_code_content) and len(parsed_lfsr_config) == 256:
                self.setup_analyzer_ui()
            else:
                messagebox.showerror("Parsing Error",
                    f"Could not parse the LUT data or found only {len(parsed_lfsr_config)} entries. "
                    "Ensure the file contains exactly 256 entries starting from index 0, in the format: "
                    "`{ 0xMASK, 0xSEED },` (comments are ignored but must be present for 256 lines).")

        except FileNotFoundError:
            messagebox.showerror("File Error", "The selected file was not found.")
        except Exception as e:
            messagebox.showerror("File Read Error", f"An unexpected error occurred while reading the file: {e}")

    def on_mouse_wheel(self, event):
        """Adjusts the vertical slider position based on mouse wheel movement, step-by-step."""
        current_value = self.level_var.get()
        step = 1

        if event.delta > 0:
            new_value = min(255, current_value + step)
        else:
            new_value = max(0, current_value - step)

        self.level_var.set(new_value)
        self.update_plots(new_value)

        return "break"

    def update_seq_len(self, *args):
        """Updates the sequence length display and re-plots the data."""
        exp = self.seq_len_exp_var.get()
        # Ensure exp is an integer for clean display and calculation
        exp = int(round(exp))
        length = 2**exp
        self.seq_len_label_var.set(f"Sequence Length: $2^{{{exp}}} = {length}$ steps")
        # Re-plot when the sequence length changes
        self.update_plots(self.level_var.get())

    def setup_analyzer_ui(self):
        """Sets up the main analysis GUI after successful parsing."""
        for widget in self.master.winfo_children():
            widget.destroy()

        # --- Data Variables ---
        self.level_var = tk.IntVar(value=127)
        self.lfsr_calc_ratio_var = tk.StringVar(value="N/A")
        self.lfsr_calc_error_var = tk.StringVar(value="N/A")
        self.seq_len_label_var = tk.StringVar()

        main_analysis_frame = ttk.Frame(self.master)
        main_analysis_frame.pack(side=tk.TOP, fill=tk.BOTH, expand=1, padx=10, pady=10)

        # --- Matplotlib Figure Setup ---
        self.fig, (self.ax_sig, self.ax_spec, self.ax_error) = plt.subplots(3, 1, figsize=(10, 7),
                                                                           gridspec_kw={'height_ratios': [2, 3, 2]})
        self.fig.tight_layout(pad=3.0)

        self.canvas = FigureCanvasTkAgg(self.fig, master=main_analysis_frame)
        self.canvas_widget = self.canvas.get_tk_widget()

        # --- Layout Grid ---
        main_analysis_frame.grid_columnconfigure(0, weight=4)
        main_analysis_frame.grid_columnconfigure(1, weight=1)
        main_analysis_frame.grid_rowconfigure(0, weight=1)

        self.canvas_widget.grid(row=0, column=0, sticky="nsew", padx=(0, 10))

        # Right side: Controls Frame
        controls_frame = ttk.Frame(main_analysis_frame, padding="10")
        controls_frame.grid(row=0, column=1, sticky="ns")

        # --- PWM Level Control ---
        ttk.Label(controls_frame, text="PWM Level (0-255):", anchor='center').pack(pady=(0, 5))
        self.level_label = ttk.Label(controls_frame, textvariable=self.level_var, font=('Arial', 12, 'bold'))
        self.level_label.pack(pady=5)

        self.level_slider = ttk.Scale(controls_frame, from_=255, to=0,
                                            orient=tk.VERTICAL, length=300,
                                            variable=self.level_var, command=self.update_plots)
        self.level_slider.pack(pady=10, fill=tk.Y, expand=True)
        self.level_slider.bind('<MouseWheel>', self.on_mouse_wheel)

        # --- Sequence Length Control (New) ---
        ttk.Separator(controls_frame, orient='horizontal').pack(fill='x', pady=10)

        ttk.Label(controls_frame, text="FFT Sequence Length ($2^N$):", anchor='center').pack(pady=(0, 5))

        # Display the length value
        self.seq_len_label = ttk.Label(controls_frame, textvariable=self.seq_len_label_var, font=('Arial', 10, 'bold'))
        self.seq_len_label.pack(pady=2)

        # Slider for N, ranging from 9 (512) to 13 (8192)
        self.seq_len_slider = ttk.Scale(controls_frame, from_=9, to=13,
                                            orient=tk.HORIZONTAL,
                                            variable=self.seq_len_exp_var, command=self.update_seq_len)
        self.seq_len_slider.pack(pady=5, fill=tk.X)

        # Initialize the length label
        self.update_seq_len()


        # --- Info Displays (At the bottom) ---
        info_frame = ttk.Frame(self.master)
        info_frame.pack(side=tk.BOTTOM, fill=tk.X, padx=10, pady=5)

        # Calculated Ratio
        ttk.Label(info_frame, text="Calculated LFSR Duty Cycle:").pack(side=tk.LEFT, padx=5)
        ttk.Label(info_frame, textvariable=self.lfsr_calc_ratio_var, foreground='green', font=('Arial', 10, 'bold', 'underline')).pack(side=tk.LEFT, padx=10)

        # Calculated Error
        ttk.Label(info_frame, text="| Calculated Quantization Error:").pack(side=tk.LEFT, padx=5)
        ttk.Label(info_frame, textvariable=self.lfsr_calc_error_var, foreground='green', font=('Arial', 10, 'bold', 'underline')).pack(side=tk.LEFT, padx=10)

        self.update_plots(self.level_var.get())

    def update_plots(self, level_val):
        """Updates all plots based on the current PWM Level and sequence length."""

        level = int(float(level_val))
        self.level_var.set(level)

        # Get the sequence length from the slider
        sequence_len = 2**int(round(self.seq_len_exp_var.get()))

        # --- . Signal Generation and Calculation ---
        # Pass the dynamic sequence_len
        lfsr_signal, calc_ratio, calc_error = generate_lfsr_pwm_signal(level, sequence_len)

        if level < len(parsed_lfsr_config):
            period = parsed_lfsr_config[level]['period']
            # Pass the dynamic sequence_len
            ordinary_signal = generate_ordinary_pwm_signal(level, period, sequence_len)
        else:
            period = 1
            ordinary_signal = np.array([])

        # --- 2. RC Integrator Simulation ---
        lfsr_filtered = simulate_rc_integrator(lfsr_signal, RC_FILTER_ALPHA)
        ord_filtered = simulate_rc_integrator(ordinary_signal, RC_FILTER_ALPHA)

        # --- 3. Update Info Variables ---
        self.lfsr_calc_ratio_var.set(f"{calc_ratio:.6f}")
        self.lfsr_calc_error_var.set(f"{calc_error:.2e}")

        # --- 4. Plot Signal Waveform (Time Domain) ---
        self.ax_sig.clear()

        # Segment length for display: min(4 cycles, sequence_len, fixed cap)
        # We cap the view at VISUAL_SEGMENT_CAP for clear viewing, but always respect the actual sequence length.
        segment_len = min(4 * period + 20, lfsr_signal.size, VISUAL_SEGMENT_CAP)

        self.ax_sig.plot(lfsr_signal[:segment_len], drawstyle='steps-post',
                         label='LFSR PWM (Raw Digital)', color='tab:blue', alpha=0.3, linewidth=0.5)

        self.ax_sig.plot(lfsr_filtered[:segment_len],
                         label='LFSR PWM (Filtered Output)', color='tab:blue', linewidth=2)

        self.ax_sig.plot(ord_filtered[:segment_len],
                         label='Ordinary PWM (Filtered Output)', color='tab:red', linestyle='--', linewidth=1.5)

        # Updated Title to reflect the total sequence length being analyzed (addressing user confusion)
        self.ax_sig.set_title(f'Filtered Output (Level {level}) - Analysis Length: {sequence_len} steps')
        self.ax_sig.set_xlabel(f'Time Step (k, Viewing first {segment_len} steps)')
        self.ax_sig.set_ylabel('Filtered Output Voltage (0-1)')
        self.ax_sig.set_ylim([-0.1, 1.1])
        self.ax_sig.set_xlim(0, segment_len) # Explicitly set xlim to segment_len
        self.ax_sig.set_yticks(np.linspace(0, 1, 6))
        self.ax_sig.grid(axis='y', alpha=0.5)
        self.ax_sig.legend(loc='upper right')

        # --- 5. Plot Spectral Response (Frequency Domain) ---
        self.ax_spec.clear()

        # FFT now uses the dynamic sequence_len
        xf_lfsr, psd_lfsr = calculate_spectral_response(lfsr_signal)
        xf_ord, psd_ord = calculate_spectral_response(ordinary_signal)

        self.ax_spec.plot(xf_lfsr, 10*np.log10(psd_lfsr + 1e-15), label='LFSR PWM (Calculated PSD)', color='tab:blue')
        self.ax_spec.plot(xf_ord, 10*np.log10(psd_ord + 1e-15), label='Ordinary PWM (Harmonics)', color='tab:red', alpha=0.7)

        # Update title to show the analysis length
        self.ax_spec.set_title(f'Spectral Response (PSD - Length: {sequence_len} steps)')
        self.ax_spec.set_xlabel('Normalized Frequency ($f/f_s$)')
        self.ax_spec.set_ylabel('Normalized Power (dB)')
        self.ax_spec.grid(True, which="major", ls="-", alpha=0.5)
        self.ax_spec.set_xlim(0, 0.5)
        self.ax_spec.legend(loc='upper right')

        # --- 6. Plot Error vs. Ideal Duty Cycle (LFSR vs. Ordinary Quantization Error) ---
        self.ax_error.clear()

        all_levels = np.arange(256)

        # Calculate LFSR Quantization Error for all 256 levels (still using ERROR_CALC_LENGTH for speed)
        all_lfsr_quant_errors = np.array([
            generate_lfsr_pwm_signal(l, ERROR_CALC_LENGTH)[2] # Get calc_error (index 2)
            for l in all_levels
        ])

        # Ordinary PWM Quantization Error
        ord_quant_errors = np.array([
            (l / 255.0) - (round((l / 255.0) * entry['period']) / entry['period'])
            for l, entry in enumerate(parsed_lfsr_config)
        ])

        # Plot 6a: Ordinary PWM Quantization Error
        self.ax_error.plot(all_levels, ord_quant_errors * 100, label='Ordinary PWM Quantization Error (Baseline)', color='tab:red', alpha=0.7)

        # Plot 6b: LFSR Calculated Quantization Error
        self.ax_error.plot(all_levels, all_lfsr_quant_errors * 100, label='LFSR Calculated Quantization Error', color='tab:blue')

        # Plot 6c: Current Calculated Error Marker
        current_sequence_len_for_display = ERROR_CALC_LENGTH # Ensure this matches the error calculation

        # Recalculate the current level's error using the length used for the error plot (512)
        # We need to make sure the marker is accurate relative to the data it's plotting.
        current_error_for_marker = generate_lfsr_pwm_signal(level, current_sequence_len_for_display)[2]

        self.ax_error.plot(level, current_error_for_marker * 100, 'o', markersize=8, color='green', label=f'Current LFSR Error {level}')

        self.ax_error.set_title(f'Quantization Error Comparison (Analysis Length: {ERROR_CALC_LENGTH} steps)')
        self.ax_error.set_xlabel('PWM Level (0-255)')
        self.ax_error.set_ylabel('Error (%)')
        self.ax_error.grid(True, which="both", ls="-", alpha=0.5)
        self.ax_error.legend(loc='lower left', prop={'size': 8})

        self.fig.tight_layout(pad=3.0)
        self.canvas.draw()

# --- Run the application ---
if __name__ == "__main__":
    root = tk.Tk()
    app = PWM_Analyzer_App(root)
    root.mainloop()
