// lfsr_analyzer.cpp
//
// Compile: g++ -O3 -std=c++17 -march=native -pthread -o lfsr_analyzer lfsr_analyzer.cpp
//
// Description:
// Reads the 'lfsr_map.bin' (8GB) generated by lfsr_viz.
// Quantizes the 16-bit duty cycle into 8-bit PWM steps (0-255).
// Extracts (Mask, Seed) pairs and bins them into '8bit_set/0xXX.bin'.
//
// Output Format:
// Files 0x00.bin ... 0xFF.bin contain a sequence of struct { uint16_t mask; uint16_t seed; }

#include <iostream>
#include <vector>
#include <thread>
#include <mutex>
#include <atomic>
#include <fstream>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <unistd.h>
#include <cmath>
#include <cstring>
#include <cstdio>
#include <algorithm>
#include <cerrno>
#include <cinttypes>
#include <cstdint>
#include <chrono>

 // -----------------------------------------------------------------------------
// Configuration
// -----------------------------------------------------------------------------
const char* INPUT_FILE = "lfsr_map_signed.bin";
const char* OUT_DIR = "8bit_set";
const size_t DIM_SIZE = 65536;
const uint64_t FILE_SIZE = (uint64_t)DIM_SIZE * (uint64_t)DIM_SIZE * sizeof(uint16_t); // 8GB

// Buffer size (in number of elements) before flushing to disk
// Larger buffer = fewer syscalls = faster, but higher RAM usage per thread.
const size_t WRITE_BUFFER_SIZE = 8192;

// -----------------------------------------------------------------------------
// Structures
// -----------------------------------------------------------------------------
#pragma pack(push, 1)
struct Entry {
    uint16_t mask;
    uint16_t seed;
};
#pragma pack(pop)

// Global file descriptors for the 256 bins
int out_fds[256];
std::mutex file_mutexes[256];

// -----------------------------------------------------------------------------
// Helper Functions
// -----------------------------------------------------------------------------

void ensure_directory() {
    struct stat st = {0};
    if (stat(OUT_DIR, &st) == -1) {
        #ifdef _WIN32
        _mkdir(OUT_DIR);
        #else
        mkdir(OUT_DIR, 0755);
        #endif
    }
}

// Safe write that handles EINTR and short writes
static ssize_t full_write(int fd, const void* buf, size_t count) {
    const char* ptr = reinterpret_cast<const char*>(buf);
    size_t remaining = count;

    while (remaining > 0) {
        ssize_t w = ::write(fd, ptr, remaining);
        if (w == -1) {
            if (errno == EINTR) continue; // retry on signal interruption
            return -1; // real error
        }
        ptr += w;
        remaining -= static_cast<size_t>(w);
    }
    return static_cast<ssize_t>(count);
}

// Open all 256 bin files (truncate mode)
void prepare_output_files() {
    ensure_directory();
    char filepath[128];
    
    std::cout << "[INFO] creating/truncating output files in " << OUT_DIR << "/...\n";
    
    for (int i = 0; i < 256; ++i) {
        snprintf(filepath, sizeof(filepath), "%s/0x%02X.bin", OUT_DIR, i);
        out_fds[i] = open(filepath, O_WRONLY | O_CREAT | O_TRUNC, 0644);
        if (out_fds[i] == -1) {
            perror("Failed to create output bin");
            // Close any previously opened fds
            for (int j = 0; j < i; ++j) if (out_fds[j] != -1) close(out_fds[j]);
            exit(1);
        }
    }
}

void close_output_files() {
    for (int i = 0; i < 256; ++i) {
        if (out_fds[i] != -1) {
            close(out_fds[i]);
            out_fds[i] = -1;
        }
    }
}

// -----------------------------------------------------------------------------
// Worker Logic
// -----------------------------------------------------------------------------

// Note: start_mask/end_mask are 32-bit (or larger) to represent DIM_SIZE properly.
void worker(uint32_t start_mask, uint32_t end_mask, const uint16_t* input_map, std::atomic<uint64_t>& processed_count) {
    // Thread-local buffers to minimize locking
    std::vector<Entry> buffers[256];
    for (int i = 0; i < 256; ++i) buffers[i].reserve(WRITE_BUFFER_SIZE + 100);

    uint64_t local_count = 0;

    for (uint32_t m = start_mask; m < end_mask; ++m) {
        uint64_t row_offset = (uint64_t)m * (uint64_t)DIM_SIZE;

        for (uint32_t s = 0; s < DIM_SIZE; ++s) {
            uint16_t duty16 = input_map[row_offset + s];

            // Quantize to 8-bit: (x * 255) / 65535
            uint8_t pwm8 = static_cast<uint8_t>((static_cast<uint32_t>(duty16) * 255u) / 65535u);

            buffers[pwm8].push_back({static_cast<uint16_t>(m), static_cast<uint16_t>(s)});

            if (buffers[pwm8].size() >= WRITE_BUFFER_SIZE) {
                std::lock_guard<std::mutex> lock(file_mutexes[pwm8]);
                size_t bytes = buffers[pwm8].size() * sizeof(Entry);
                if (full_write(out_fds[pwm8], buffers[pwm8].data(), bytes) == -1) {
                    perror("write");
                    std::exit(1);
                }
                buffers[pwm8].clear();
            }
        }

        local_count += DIM_SIZE;
        if (local_count >= DIM_SIZE * 16) { // update progress periodically
            processed_count.fetch_add(local_count, std::memory_order_relaxed);
            local_count = 0;
        }
    }

    // Flush remaining data in all buffers
    for (int i = 0; i < 256; ++i) {
        if (!buffers[i].empty()) {
            std::lock_guard<std::mutex> lock(file_mutexes[i]);
            size_t bytes = buffers[i].size() * sizeof(Entry);
            if (full_write(out_fds[i], buffers[i].data(), bytes) == -1) {
                perror("write");
                std::exit(1);
            }
            buffers[i].clear();
        }
    }

    if (local_count) processed_count.fetch_add(local_count, std::memory_order_relaxed);
}

// -----------------------------------------------------------------------------
// Main
// -----------------------------------------------------------------------------

int main() {
    // Sanity static assert
    static_assert(DIM_SIZE == 65536, "Expected DIM_SIZE == 65536");

    // Initialize out_fds to -1 so close_output_files is safe on early exit
    for (int i = 0; i < 256; ++i) out_fds[i] = -1;

    // 1. Check Input file
    int fd = open(INPUT_FILE, O_RDONLY);
    if (fd == -1) {
        std::cerr << "[ERROR] Could not open " << INPUT_FILE << ". Run lfsr_viz first.\n";
        return 1;
    }

    struct stat st;
    if (fstat(fd, &st) == -1) {
        perror("fstat");
        close(fd);
        return 1;
    }
    uint64_t actual_size = static_cast<uint64_t>(st.st_size);
    if (actual_size != FILE_SIZE) {
        std::cerr << "[ERROR] File size mismatch. Expected " << FILE_SIZE << " bytes but got " << actual_size << ".\n";
        close(fd);
        return 1;
    }

    // 2. Map Input
    std::cout << "[INFO] Mapping dataset into memory...\n";
    const uint16_t* data = reinterpret_cast<const uint16_t*>(
        mmap(nullptr, (size_t)FILE_SIZE, PROT_READ, MAP_SHARED, fd, 0)
    );
    if (data == MAP_FAILED) {
        perror("mmap");
        close(fd);
        return 1;
    }

    // 3. Prepare Output
    prepare_output_files();

    // 4. Launch Threads
    unsigned int hw = std::thread::hardware_concurrency();
    int num_threads = hw ? static_cast<int>(hw) : 4;
    std::cout << "[INFO] processing with " << num_threads << " threads...\n";

    std::vector<std::thread> threads;
    std::atomic<uint64_t> processed_count(0);

    // Use uint32_t indexing and safe chunking
    uint32_t total_rows = static_cast<uint32_t>(DIM_SIZE);
    uint32_t chunk_size = (total_rows + (uint32_t)num_threads - 1u) / (uint32_t)num_threads; // ceil-div

    for (int t = 0; t < num_threads; ++t) {
        uint32_t start = static_cast<uint32_t>(t) * chunk_size;
        uint32_t end = start + chunk_size;
        if (end > total_rows) end = total_rows;
        if (start >= end) continue; // safety (in case num_threads > total_rows)

        threads.emplace_back(worker, start, end, data, std::ref(processed_count));
    }

    // 5. Monitor Progress
    uint64_t total_points = (uint64_t)DIM_SIZE * (uint64_t)DIM_SIZE;
    auto start_time = std::chrono::high_resolution_clock::now();

    while (processed_count.load(std::memory_order_relaxed) < total_points) {
        uint64_t p = processed_count.load(std::memory_order_relaxed);
        double pct = (double)p / (double)total_points * 100.0;
        printf("\r[Analyzing] %.2f%% Complete (%" PRIu64 " / %" PRIu64 ")", pct, p, total_points);
        fflush(stdout);
        std::this_thread::sleep_for(std::chrono::milliseconds(500));
    }

    // join threads
    for (auto& th : threads) if (th.joinable()) th.join();

    auto end_time = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double> diff = end_time - start_time;

    printf("\r[DONE] 100.00%% Complete. Time: %.2fs\n", diff.count());

    // 6. Cleanup
    close_output_files();
    munmap(const_cast<uint16_t*>(data), (size_t)FILE_SIZE);
    close(fd);

    std::cout << "[INFO] Analysis complete. Data stored in '" << OUT_DIR << "/'.\n";

    return 0;
}
