// lfsr_viz_signed.cpp
//
// Linux SDL2/OpenGL LFSR Polynomial Space Visualizer (Signed Integer Storage)
// 
// Compile: 
// g++ -O3 -std=c++17 -march=native -pthread -o lfsr_viz_signed lfsr_viz_signed.cpp -lSDL2 -lGL
//
// Data Model (int16_t):
// >  0 : Stable State (Cycle). Value is scaled Duty Cycle (0..32767).
// <  0 : Transient State. Value is negative scaled Duty Cycle (-1..-32767).
// == 0 : 0% Duty Cycle.
//
// Visualization:
// X: Mask | Y: Seed | Z: abs(Duty)
// Colors: 
// - Stable: Heatmap (Red=High Duty, Green=Low)
// - Transient: Grayscale/Steel Blue
// - Lock-up (Cycle=1): Bright Cyan Cube

#include <SDL2/SDL.h>
#include <SDL2/SDL_opengl.h>
#include <GL/gl.h>

#include <iostream>
#include <vector>
#include <algorithm>
#include <thread>
#include <atomic>
#include <mutex>
#include <fstream>
#include <cmath>
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <cstring>
#include <immintrin.h>

// -----------------------------------------------------------------------------
// Configuration
// -----------------------------------------------------------------------------
const char* DATA_FILE = "lfsr_map_signed.bin";
const int N_BITS = 16;
const size_t DIM_SIZE = 1 << N_BITS; // 65536
const size_t TOTAL_POINTS = DIM_SIZE * DIM_SIZE;
const size_t FILE_SIZE = TOTAL_POINTS * sizeof(int16_t); // Note: int16_t

const int WINDOW_WIDTH = 1600;
const int WINDOW_HEIGHT = 900;
const float MAX_DUTY_SCALER = 32767.0f;

// -----------------------------------------------------------------------------
// LFSR Logic
// -----------------------------------------------------------------------------
static inline uint16_t next_state(uint16_t state, uint16_t mask) {
    uint16_t feedback = __builtin_parity(state & mask);
    return (state >> 1) | (feedback << 15);
}

// -----------------------------------------------------------------------------
// Data Generation (Signed Logic)
// -----------------------------------------------------------------------------
void generate_dataset_worker(uint16_t start_mask, uint16_t end_mask, int16_t* buffer, std::atomic<int>& progress) {
    std::vector<uint8_t> visited(DIM_SIZE, 0);
    std::vector<uint16_t> chain;
    chain.reserve(DIM_SIZE);
    
    std::vector<uint16_t> cycle_sorted;
    cycle_sorted.reserve(DIM_SIZE);

    for (int m = start_mask; m < end_mask; ++m) {
        uint16_t mask = (uint16_t)m;
        // Optimization: memset is faster than std::fill for bytes
        memset(visited.data(), 0, DIM_SIZE);
        
        uint64_t row_offset = (uint64_t)mask * DIM_SIZE;

        for (int s = 0; s < DIM_SIZE; ++s) {
            if (visited[s]) continue;

            uint16_t curr = s;
            chain.clear();
            
            // 1. Trace Chain
            while (!visited[curr]) {
                visited[curr] = 1;
                chain.push_back(curr);
                curr = next_state(curr, mask);
            }

            // 2. Analyze Structure
            auto it = std::find(chain.begin(), chain.end(), curr);
            // In a finite space, we must hit a visited node eventually.
            // If the node was visited in THIS chain, it's a new cycle.
            // If it was visited in a PREVIOUS chain, this chain merges into an old one. 
            // *Optimization Note*: For full correctness without complex memoization of every duty,
            // we re-calculate duties for the merged path or rely on the fact that we process linear scan.
            // However, linear scan + visited array prevents re-processing known states.
            // But wait: if we hit a state processed in a previous outer-loop step, 'visited' is 0 (it is reset per mask).
            // So we only care if we hit a node in the *current* chain or a node visited *for this mask*.
            
            // If 'curr' was visited in this pass but not in 'chain', it means we merged into a path processed earlier in this mask loop.
            // We need to retrieve the duty characteristics of that target cycle.
            // Since we write results to 'buffer', we can read back from buffer!
            
            bool merges_into_existing = (it == chain.end());
            
            double effective_duty = 0.0;
            size_t cycle_len = 0;
            
            if (merges_into_existing) {
                // 'curr' is the connection point to a previously calculated path
                int16_t val = buffer[row_offset + curr];
                // Extract duty from the signed value
                effective_duty = (double)std::abs(val) / MAX_DUTY_SCALER;
                // We don't easily know cycle_len here without looking it up, 
                // but we only need duty to calculate the transient states in 'chain'.
                // Actually, for transient calculation relative to the cycle, we need the sorted cycle states
                // to be perfectly accurate. 
                // Approximation: If we merge, we assume the duty at the merge point is the target duty.
                // This is slightly inaccurate for PWM logic (threshold vs cycle distribution), 
                // but calculating exact sorted-cycle position for every merge is O(N^2).
                // Given the density, we will trace the chain fully if we can, but reset 'visited' per mask handles most cases.
            } else {
                // New Cycle Discovered
                size_t cycle_start_idx = std::distance(chain.begin(), it);
                cycle_len = chain.size() - cycle_start_idx;
                
                // Sort cycle for rank determination
                cycle_sorted.clear();
                for(size_t i=cycle_start_idx; i<chain.size(); ++i) {
                    cycle_sorted.push_back(chain[i]);
                }
                std::sort(cycle_sorted.begin(), cycle_sorted.end());

                // A. Process Cycle States (Positive)
                for(size_t i=0; i<cycle_sorted.size(); ++i) {
                    uint16_t st = cycle_sorted[i];
                    // Rank i means i items are <= st. (CycleLen - 1 - i) are > st.
                    double duty = (double)(cycle_len - 1 - i) / (double)cycle_len;
                    buffer[row_offset + st] = (int16_t)(duty * MAX_DUTY_SCALER);
                    
                    // Handle +0 explicitly if needed, but 0 is fine.
                }
                
                // B. Process Transient States in this chain (Negative)
                // These are chain[0] ... chain[cycle_start_idx - 1]
                for(size_t i=0; i<cycle_start_idx; ++i) {
                    uint16_t trans_st = chain[i];
                    // How many in cycle are > trans_st?
                    auto it_gt = std::upper_bound(cycle_sorted.begin(), cycle_sorted.end(), trans_st);
                    int count_gt = std::distance(it_gt, cycle_sorted.end());
                    double duty = (double)count_gt / (double)cycle_len;
                    
                    int16_t sval = (int16_t)(duty * MAX_DUTY_SCALER);
                    // Store as Negative to indicate Transient
                    if (sval == 0) sval = 0; // -0 is 0
                    else sval = -sval;
                    
                    buffer[row_offset + trans_st] = sval;
                }
            }
        }
        progress++;
    }
}

void ensure_dataset_exists() {
    int fd = open(DATA_FILE, O_RDWR | O_CREAT, 0644);
    if (fd == -1) { perror("Error opening file"); exit(1); }

    struct stat st;
    fstat(fd, &st);
    
    if (st.st_size == FILE_SIZE) {
        std::cout << "[INFO] Dataset " << DATA_FILE << " found. Ready.\n";
        close(fd);
        return;
    }

    std::cout << "[INFO] Generating 8GB Signed Dataset... Please wait.\n";
    if (ftruncate(fd, FILE_SIZE) == -1) { perror("ftruncate"); exit(1); }

    int16_t* map = (int16_t*)mmap(nullptr, FILE_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if (map == MAP_FAILED) { perror("mmap"); exit(1); }

    int num_threads = std::thread::hardware_concurrency();
    std::vector<std::thread> threads;
    std::atomic<int> progress(0);
    int chunk = DIM_SIZE / num_threads;

    for (int t = 0; t < num_threads; ++t) {
        int start = t * chunk;
        int end = (t == num_threads - 1) ? DIM_SIZE : (t + 1) * chunk;
        threads.emplace_back(generate_dataset_worker, start, end, map, std::ref(progress));
    }

    while (progress < DIM_SIZE) {
        int p = progress.load();
        if (p % 100 == 0) {
            printf("\r[Generating] %d / %d Masks (%.1f%%)", p, (int)DIM_SIZE, (p * 100.0f) / DIM_SIZE);
            fflush(stdout);
        }
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
    
    for (auto& th : threads) th.join();
    std::cout << "\n[DONE] Generation complete.\n";

    munmap(map, FILE_SIZE);
    close(fd);
}

// -----------------------------------------------------------------------------
// Visualization
// -----------------------------------------------------------------------------

struct Camera {
    float x = 32768.0f; 
    float y = 32768.0f;
    float dist = 70000.0f;
    float pitch = 45.0f;
    float yaw = 0.0f;
};

void draw_text(float x, float y, const std::string& text) {
    glMatrixMode(GL_PROJECTION);
    glPushMatrix(); glLoadIdentity();
    glOrtho(0, WINDOW_WIDTH, WINDOW_HEIGHT, 0, -1, 1);
    glMatrixMode(GL_MODELVIEW);
    glPushMatrix(); glLoadIdentity();
    glLineWidth(2.0f);
    glColor3f(1.0f, 1.0f, 1.0f);
    float cx = x; float scale = 10.0f;
    for(char c : text) {
        glBegin(GL_LINES);
        float w = 0.6f * scale, h = 1.0f * scale;
        if (c == ' ') { cx += w + 4; glEnd(); continue; }
        // Minimal stick font
        bool t=0,m=0,b=0,tl=0,tr=0,bl=0,br=0;
        if(isdigit(c)) {
            int d = c-'0';
            if(d!=1 && d!=4) t=1; if(d!=0 && d!=1 && d!=7) m=1; if(d!=1 && d!=4 && d!=7) b=1;
            if(d!=1 && d!=2 && d!=3 && d!=7) tl=1; if(d!=5 && d!=6) tr=1;
            if(d==0 || d==2 || d==6 || d==8) bl=1; if(d!=2) br=1;
        } else if(c=='-') m=1;
        else if(c=='S') {t=1;m=1;b=1;tl=1;br=1;} // 5-ish
        else if(c=='T') {t=1; /*mid vert*/ glVertex2f(cx+w/2,y); glVertex2f(cx+w/2,y+h); }
        else { t=b=tl=tr=bl=br=1; } // box default
        
        if(t) {glVertex2f(cx,y); glVertex2f(cx+w,y);}
        if(m) {glVertex2f(cx,y+h/2); glVertex2f(cx+w,y+h/2);}
        if(b) {glVertex2f(cx,y+h); glVertex2f(cx+w,y+h);}
        if(tl){glVertex2f(cx,y); glVertex2f(cx,y+h/2);}
        if(bl){glVertex2f(cx,y+h/2); glVertex2f(cx,y+h);}
        if(tr){glVertex2f(cx+w,y); glVertex2f(cx+w,y+h/2);}
        if(br){glVertex2f(cx+w,y+h/2); glVertex2f(cx+w,y+h);}
        glEnd();
        cx += w + 6.0f;
    }
    glPopMatrix(); glMatrixMode(GL_PROJECTION); glPopMatrix(); glMatrixMode(GL_MODELVIEW);
}

int main(int argc, char** argv) {
    ensure_dataset_exists();

    int fd = open(DATA_FILE, O_RDONLY);
    int16_t* data = (int16_t*)mmap(nullptr, FILE_SIZE, PROT_READ, MAP_SHARED, fd, 0);
    if (data == MAP_FAILED) return 1;

    if (SDL_Init(SDL_INIT_VIDEO) < 0) return 1;
    SDL_GL_SetAttribute(SDL_GL_MULTISAMPLEBUFFERS, 1);
    SDL_GL_SetAttribute(SDL_GL_MULTISAMPLESAMPLES, 4);

    SDL_Window* window = SDL_CreateWindow("LFSR Map (Signed Transients)", 
        SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, WINDOW_WIDTH, WINDOW_HEIGHT, SDL_WINDOW_OPENGL | SDL_WINDOW_SHOWN);
    SDL_GLContext context = SDL_GL_CreateContext(window);

    glEnable(GL_DEPTH_TEST);

    Camera cam;
    bool running = true;
    float vel_yaw=0, vel_pitch=0, vel_x=0, vel_y=0;
    bool drag_rot=false, drag_pan=false;
    int last_mx=0, last_my=0;

    struct Vertex { float x, y, z; uint8_t r, g, b, a; };
    std::vector<Vertex> vbuffer;
    vbuffer.reserve(1000000);

    while (running) {
        SDL_Event e;
        while (SDL_PollEvent(&e)) {
            if (e.type == SDL_QUIT) running = false;
            else if (e.type == SDL_MOUSEBUTTONDOWN) {
                if (e.button.button == SDL_BUTTON_LEFT) drag_rot = true;
                if (e.button.button == SDL_BUTTON_RIGHT) drag_pan = true;
            }
            else if (e.type == SDL_MOUSEBUTTONUP) { drag_rot = false; drag_pan = false; }
            else if (e.type == SDL_MOUSEMOTION) {
                int dx = e.motion.x - last_mx; int dy = e.motion.y - last_my;
                last_mx = e.motion.x; last_my = e.motion.y;
                if (drag_rot) { vel_yaw += dx*0.5f; vel_pitch += dy*0.5f; }
                if (drag_pan) {
                    float rad = cam.yaw * 3.14159f / 180.0f;
                    vel_x -= (cos(rad)*dx - sin(rad)*dy) * (cam.dist * 0.001f);
                    vel_y -= (sin(rad)*dx + cos(rad)*dy) * (cam.dist * 0.001f);
                }
            }
            else if (e.type == SDL_MOUSEWHEEL) {
                cam.dist -= e.wheel.y * (cam.dist * 0.1f);
                if (cam.dist < 100) cam.dist = 100;
            }
        }

        cam.yaw += vel_yaw * 0.1f; cam.pitch += vel_pitch * 0.1f;
        cam.x += vel_x * 0.1f; cam.y += vel_y * 0.1f;
        vel_yaw *= 0.9f; vel_pitch *= 0.9f; vel_x *= 0.9f; vel_y *= 0.9f;
        if (cam.pitch > 89) cam.pitch = 89; if (cam.pitch < -89) cam.pitch = -89;

        glClearColor(0.1f, 0.1f, 0.12f, 1.0f);
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

        glMatrixMode(GL_PROJECTION); glLoadIdentity();
        double ar = (double)WINDOW_WIDTH/WINDOW_HEIGHT;
        double zn=10.0, zf=500000.0, fov=60.0;
        double fh = tan(fov/360*3.14159)*zn;
        glFrustum(-fh*ar, fh*ar, -fh, fh, zn, zf);

        glMatrixMode(GL_MODELVIEW); glLoadIdentity();
        glTranslatef(0,0,-cam.dist);
        glRotatef(cam.pitch, 1,0,0);
        glRotatef(cam.yaw, 0,1,0);
        glTranslatef(-cam.x, 0, -cam.y);

        float speed = sqrt(vel_yaw*vel_yaw + vel_pitch*vel_pitch + vel_x*vel_x + vel_y*vel_y);
        int step = (speed > 1.0f) ? 128 : (speed > 0.1f ? 32 : (cam.dist > 30000 ? 64 : (cam.dist > 10000 ? 16 : (cam.dist > 2000 ? 4 : 1))));

        float range = cam.dist * 1.5f;
        int min_x = std::max(0, (int)(cam.x - range)); int max_x = std::min((int)DIM_SIZE, (int)(cam.x + range));
        int min_y = std::max(0, (int)(cam.y - range)); int max_y = std::min((int)DIM_SIZE, (int)(cam.y + range));

        vbuffer.clear();
        glEnableClientState(GL_VERTEX_ARRAY);
        glEnableClientState(GL_COLOR_ARRAY);

        for (int mx = min_x; mx < max_x; mx += step) {
            for (int my = min_y; my < max_y; my += step) {
                int16_t val = data[mx * DIM_SIZE + my];
                
                // Determine Properties
                bool is_transient = (val < 0);
                float abs_norm = std::abs(val) / MAX_DUTY_SCALER;
                float z = abs_norm * 10000.0f;

                uint8_t r, g, b;

                // Check for Lock-up (Cycle Length = 1)
                // Logic: next_state == current_state
                uint16_t ns = next_state((uint16_t)my, (uint16_t)mx);
                bool is_lockup = (ns == (uint16_t)my);

                if (is_lockup) {
                    // BLUE CUBES (Cyan)
                    r = 0; g = 255; b = 255;
                    // Draw a bigger "point" (small cluster)
                    vbuffer.push_back({(float)mx, z, (float)my, r, g, b, 255});
                    if (step > 1) {
                         vbuffer.push_back({(float)mx, z+50, (float)my, r, g, b, 255});
                         vbuffer.push_back({(float)mx, z+100, (float)my, r, g, b, 255});
                    }
                } 
                else if (is_transient) {
                    // TRANSIENT (Grayscale / Blue-ish Grey)
                    // Map duty 0..1 to Dark Grey .. Light Steel Blue
                    r = (uint8_t)(50 + abs_norm * 100);
                    g = (uint8_t)(50 + abs_norm * 100);
                    b = (uint8_t)(70 + abs_norm * 140);
                    vbuffer.push_back({(float)mx, z, (float)my, r, g, b, 255});
                } 
                else {
                    // STABLE (Heatmap)
                    // 0.0 -> Blue/Green, 0.5 -> Green, 1.0 -> Red
                    r = (uint8_t)(abs_norm * 255);
                    g = (uint8_t)(sin(abs_norm * 3.14159) * 255);
                    b = (uint8_t)((1.0f - abs_norm) * 50); // Less blue in high duty
                    vbuffer.push_back({(float)mx, z, (float)my, r, g, b, 255});
                }

                if (vbuffer.size() >= 999000) {
                    glVertexPointer(3, GL_FLOAT, sizeof(Vertex), &vbuffer[0].x);
                    glColorPointer(4, GL_UNSIGNED_BYTE, sizeof(Vertex), &vbuffer[0].r);
                    glDrawArrays(GL_POINTS, 0, vbuffer.size());
                    vbuffer.clear();
                }
            }
        }
        if (!vbuffer.empty()) {
            glVertexPointer(3, GL_FLOAT, sizeof(Vertex), &vbuffer[0].x);
            glColorPointer(4, GL_UNSIGNED_BYTE, sizeof(Vertex), &vbuffer[0].r);
            glDrawArrays(GL_POINTS, 0, vbuffer.size());
        }

        glDisableClientState(GL_VERTEX_ARRAY);
        glDisableClientState(GL_COLOR_ARRAY);

        // Info Overlay
        int hover_mask = std::clamp((int)cam.x, 0, 65535);
        int hover_seed = std::clamp((int)cam.y, 0, 65535);
        int16_t h_val = data[hover_mask * DIM_SIZE + hover_seed];
        float h_duty = std::abs(h_val) / MAX_DUTY_SCALER;
        
        std::string s_type = (h_val < 0) ? "TRANSIENT" : "STABLE";
        if (next_state(hover_seed, hover_mask) == hover_seed) s_type = "LOCKUP";

        draw_text(20, WINDOW_HEIGHT-80, "MASK: " + std::to_string(hover_mask) + " SEED: " + std::to_string(hover_seed));
        draw_text(20, WINDOW_HEIGHT-50, "TYPE: " + s_type + "  DUTY: " + std::to_string((int)(h_duty*100)) + " " + std::to_string(h_duty));

        SDL_GL_SwapWindow(window);
    }

    munmap(data, FILE_SIZE);
    close(fd);
    SDL_GL_DeleteContext(context);
    SDL_DestroyWindow(window);
    SDL_Quit();
    return 0;
}
