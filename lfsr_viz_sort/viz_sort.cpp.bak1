// lfsr_analytics_viz.cpp
//
// Compile: g++ -O3 -std=c++17 -march=native -o lfsr_analytics_viz lfsr_analytics_viz.cpp -lfltk -lfltk_gl -lGL -lGLU -lpthread

#include <FL/Fl.H>
#include <FL/Fl_Gl_Window.H>
#include <FL/Fl_Double_Window.H>
#include <FL/Fl_Check_Browser.H>
#include <FL/Fl_Button.H>
#include <FL/Fl_Group.H>
#include <FL/Fl_Box.H>
#include <FL/Fl_Tabs.H>
#include <FL/Fl_Scroll.H>
#include <FL/gl.h>
#include <GL/glu.h>

#include <iostream>
#include <vector>
#include <string>
#include <cmath>
#include <fstream>
#include <algorithm>
#include <iomanip>
#include <mutex>
#include <array>
#include <atomic>
#include <cstdlib>

// -----------------------------------------------------------------------------
// Data Structures
// -----------------------------------------------------------------------------
struct Point2D {
    uint16_t mask;
    uint16_t seed;
};

struct BinData {
    int id;
    std::vector<Point2D> points;
    bool visible;
    float r, g, b;
    BinData() : id(-1), visible(false), r(1.0f), g(1.0f), b(1.0f) {}
};

// Evaluation result per LFSR point
struct EvalResult {
    Point2D p;
    int bin_id;
    std::array<int,8> section_counts{};
    int total_on = 0;
    double symmetry_score = 0.0; // variance (lower = more symmetric)
    // computed once
};

// Global State
static std::vector<BinData> g_bins(256);
static std::mutex g_data_mutex;

// Eval results per bin
static std::vector<std::vector<EvalResult>> g_eval_by_bin(256);

// Flattened list used by the octagon viewer (updated from g_eval_by_bin)
static std::vector<const EvalResult*> g_eval_flat;

// Statistics
struct Stats {
    size_t total_points = 0;
    double avg_mask = 0;
    double avg_seed = 0;
    double density = 0;
    int visible_bins = 0;
};
static Stats g_stats;

// Sorting control
static std::atomic<bool> g_sorting(false);
static std::atomic<bool> g_stop_sort(false);

// -----------------------------------------------------------------------------
// Helper Functions
// -----------------------------------------------------------------------------
void get_color(int id, float& r, float& g, float& b) {
    float t = id / 255.0f;
    r = t;
    g = std::sin(t * 3.14159265f);
    b = 1.0f - t;
}

// parity16: count parity of 16-bit word (returns 0/1)
static inline uint16_t parity16(uint16_t x) {
    // builtin parity can be used but portable approach below:
    x ^= x >> 8;
    x ^= x >> 4;
    x ^= x >> 2;
    x ^= x >> 1;
    return x & 1;
}

// Load a specific bin file if not already loaded
void load_bin(int id) {
    // If already loaded, nothing to do
    if (!g_bins[id].points.empty()) return;

    char filename[128];
    std::snprintf(filename, sizeof(filename), "8bit_set/0x%02X.bin", id);

    std::ifstream file(filename, std::ios::binary | std::ios::ate);
    if (!file.is_open()) {
        std::cerr << "Failed to open '" << filename << "'\n";
        return;
    }

    std::streamsize size = file.tellg();
    if (size <= 0) {
        std::cerr << "Empty file '" << filename << "'\n";
        return;
    }

    if (size % sizeof(Point2D) != 0) {
        std::cerr << "File size not multiple of Point2D for '" << filename << "'\n";
        return;
    }

    file.seekg(0, std::ios::beg);
    size_t count = static_cast<size_t>(size / sizeof(Point2D));
    std::vector<Point2D> tmp(count);

    if (!file.read(reinterpret_cast<char*>(tmp.data()), size)) {
        std::cerr << "Failed read for '" << filename << "'\n";
        return;
    }

    // Move into the global bin
    {
        std::lock_guard<std::mutex> lock(g_data_mutex);
        g_bins[id].points = std::move(tmp);
        g_bins[id].id = id;
        get_color(id, g_bins[id].r, g_bins[id].g, g_bins[id].b);
    }
}

// Unload to save RAM
void unload_bin(int id) {
    std::lock_guard<std::mutex> lock(g_data_mutex);
    std::vector<Point2D>().swap(g_bins[id].points);
    g_bins[id].visible = false;
}

void update_stats() {
    size_t count = 0;
    double sum_m = 0.0;
    double sum_s = 0.0;
    int bins = 0;

    for (int i = 0; i < 256; ++i) {
        std::lock_guard<std::mutex> lock(g_data_mutex);
        if (g_bins[i].visible && !g_bins[i].points.empty()) {
            const auto &pts = g_bins[i].points;
            size_t n = pts.size();
            count += n;
            bins++;

            size_t step = std::max<size_t>(1, n / 100);
            size_t sampled = 0;
            double local_sum_m = 0.0;
            double local_sum_s = 0.0;
            for (size_t k = 0; k < n; k += step) {
                local_sum_m += pts[k].mask;
                local_sum_s += pts[k].seed;
                sampled++;
            }
            if (sampled > 0) {
                double scale = static_cast<double>(n) / static_cast<double>(sampled);
                sum_m += local_sum_m * scale;
                sum_s += local_sum_s * scale;
            }
        }
    }

    g_stats.total_points = count;
    g_stats.visible_bins = bins;
    g_stats.avg_mask = (count > 0) ? (sum_m / static_cast<double>(count)) : 0.0;
    g_stats.avg_seed = (count > 0) ? (sum_s / static_cast<double>(count)) : 0.0;
    g_stats.density = (count > 0) ? (static_cast<double>(count) / (65536.0 * 65536.0) * 100.0) : 0.0;
}

// Save all bins back to files (overwrites)
void save_all_bins() {
    std::lock_guard<std::mutex> lock(g_data_mutex);
    for (int id = 0; id < 256; ++id) {
        if (g_bins[id].points.empty()) continue;
        char filename[128];
        std::snprintf(filename, sizeof(filename), "8bit_set/0x%02X.bin", id);
        std::ofstream out(filename, std::ios::binary | std::ios::trunc);
        if (!out.is_open()) {
            std::cerr << "Failed to open for write: " << filename << "\n";
            continue;
        }
        out.write(reinterpret_cast<const char*>(g_bins[id].points.data()),
                  static_cast<std::streamsize>(g_bins[id].points.size() * sizeof(Point2D)));
        out.close();
        std::cerr << "Saved bin " << id << " (" << g_bins[id].points.size() << " pts) -> " << filename << "\n";
    }
}

// -----------------------------------------------------------------------------
// OpenGL Visualization Widget (original large point cloud view)
// -----------------------------------------------------------------------------
class LFSRView : public Fl_Gl_Window {
    float cam_dist = 85000.0f;
    float cam_pitch = 45.0f;
    float cam_yaw = 0.0f;
    float cam_x = 32768.0f;
    float cam_y = 32768.0f;

    int last_mx = 0, last_my = 0;
    bool drag_rot = false, drag_pan = false;

public:
    LFSRView(int x, int y, int w, int h) : Fl_Gl_Window(x, y, w, h) {
        mode(FL_RGB | FL_DOUBLE | FL_DEPTH | FL_MULTISAMPLE);
    }

    void draw() override {
        if (!valid()) {
            glEnable(GL_DEPTH_TEST);
            glEnable(GL_BLEND);
            glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
            glEnable(GL_POINT_SMOOTH);
            glPointSize(2.0f);
            glClearColor(0.1f, 0.1f, 0.15f, 1.0f);
            glViewport(0, 0, w(), h());
        }

        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

        glMatrixMode(GL_PROJECTION);
        glLoadIdentity();
        gluPerspective(60.0, (double)w() / (h() > 0 ? h() : 1), 100.0, 300000.0);

        glMatrixMode(GL_MODELVIEW);
        glLoadIdentity();
        glTranslatef(0.0f, 0.0f, -cam_dist);
        glRotatef(cam_pitch, 1.0f, 0.0f, 0.0f);
        glRotatef(cam_yaw, 0.0f, 1.0f, 0.0f);
        glTranslatef(-cam_x, 0.0f, -cam_y);

        // Draw Axes Box (0..65535)
        glColor3f(0.3f, 0.3f, 0.3f);
        glLineWidth(1.0f);
        glBegin(GL_LINE_LOOP);
        glVertex3f(0.0f, 0.0f, 0.0f); glVertex3f(65535.0f, 0.0f, 0.0f);
        glVertex3f(65535.0f, 0.0f, 65535.0f); glVertex3f(0.0f, 0.0f, 65535.0f);
        glEnd();

        // Render Points
        glBegin(GL_POINTS);
        size_t total = g_stats.total_points;
        int skip = 1;
        if (total > 2000000) skip = static_cast<int>(total / 2000000);
        if (skip < 1) skip = 1;

        {
            std::lock_guard<std::mutex> lock(g_data_mutex);
            for (const auto& bin : g_bins) {
                if (!bin.visible || bin.points.empty()) continue;

                glColor3f(bin.r, bin.g, bin.b);

                float height = static_cast<float>(bin.id) / 255.0f * 15000.0f;

                const auto &pts = bin.points;
                for (size_t i = 0; i < pts.size(); i += skip) {
                    glVertex3f(static_cast<float>(pts[i].mask),
                               height,
                               static_cast<float>(pts[i].seed));
                }
            }
        }
        glEnd();

        // Draw selection crosshair for reference
        glColor4f(1.0f, 1.0f, 1.0f, 0.2f);
        glBegin(GL_LINES);
        glVertex3f(cam_x - 1000.0f, 0.0f, cam_y); glVertex3f(cam_x + 1000.0f, 0.0f, cam_y);
        glVertex3f(cam_x, 0.0f, cam_y - 1000.0f); glVertex3f(cam_x, 0.0f, cam_y + 1000.0f);
        glEnd();
    }

    int handle(int event) override {
        switch (event) {
            case FL_PUSH:
                last_mx = Fl::event_x();
                last_my = Fl::event_y();
                if (Fl::event_button() == FL_LEFT_MOUSE) drag_rot = true;
                if (Fl::event_button() == FL_RIGHT_MOUSE) drag_pan = true;
                return 1;
            case FL_RELEASE:
                drag_rot = false;
                drag_pan = false;
                return 1;
            case FL_DRAG: {
                int dx = Fl::event_x() - last_mx;
                int dy = Fl::event_y() - last_my;
                last_mx = Fl::event_x();
                last_my = Fl::event_y();

                if (drag_rot) {
                    cam_yaw += dx * 0.5f;
                    cam_pitch += dy * 0.5f;
                }
                if (drag_pan) {
                    float rad = cam_yaw * 3.14159265f / 180.0f;
                    float c = std::cos(rad), s = std::sin(rad);
                    cam_x -= (c * dx - s * dy) * (cam_dist * 0.001f);
                    cam_y -= (s * dx + c * dy) * (cam_dist * 0.001f);
                }
                redraw();
                return 1;
            }
            case FL_MOUSEWHEEL:
                cam_dist -= Fl::event_dy() * (cam_dist * 0.1f);
                if (cam_dist < 100.0f) cam_dist = 100.0f;
                redraw();
                return 1;
            default:
                return Fl_Gl_Window::handle(event);
        }
    }
};

// -----------------------------------------------------------------------------
// Octagon sorting visualization widget
// -----------------------------------------------------------------------------
class OctagonSortView : public Fl_Gl_Window {
    float cam_dist = 220000.0f;
    float cam_pitch = 45.0f;
    float cam_yaw = 0.0f;
    float cam_x = 32768.0f;
    float cam_y = 32768.0f;

    int last_mx = 0, last_my = 0;
    bool drag_rot = false, drag_pan = false;

public:
    OctagonSortView(int x, int y, int w, int h) : Fl_Gl_Window(x, y, w, h) {
        mode(FL_RGB | FL_DOUBLE | FL_DEPTH | FL_MULTISAMPLE);
    }

    void draw_octagon_at(float cx, float cy, float cz, const EvalResult &er, float base_scale, float rcol, float gcol, float bcol) {
        // compute per-vertex radius from section_counts
        int max_section = 1;
        for (int k = 0; k < 8; ++k) if (er.section_counts[k] > max_section) max_section = er.section_counts[k];

        // base radius scaled by bin scaling
        float radius_base = 1000.0f * base_scale;

        glColor4f(rcol, gcol, bcol, 0.85f);
        glBegin(GL_POLYGON);
        for (int k = 0; k < 8; ++k) {
            float ang = 2.0f * 3.14159265358979323846f * (float)k / 8.0f;
            float frac = static_cast<float>(er.section_counts[k]) / static_cast<float>(max_section);
            float r = radius_base * (0.25f + 0.75f * frac); // keep a minimum radius
            float vx = cx + std::cos(ang) * r;
            float vz = cz + std::sin(ang) * r;
            glVertex3f(vx, cy, vz);
        }
        glEnd();

        // outline
        glColor4f(0.0f, 0.0f, 0.0f, 0.6f);
        glLineWidth(1.0f);
        glBegin(GL_LINE_LOOP);
        for (int k = 0; k < 8; ++k) {
            float ang = 2.0f * 3.14159265358979323846f * (float)k / 8.0f;
            float frac = static_cast<float>(er.section_counts[k]) / static_cast<float>(max_section);
            float r = radius_base * (0.25f + 0.75f * frac);
            float vx = cx + std::cos(ang) * r;
            float vz = cz + std::sin(ang) * r;
            glVertex3f(vx, cy, vz);
        }
        glEnd();
    }

    void draw() override {
        if (!valid()) {
            glEnable(GL_DEPTH_TEST);
            glEnable(GL_BLEND);
            glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
            glEnable(GL_LINE_SMOOTH);
            glPointSize(2.0f);
            glClearColor(0.08f, 0.08f, 0.12f, 1.0f);
            glViewport(0, 0, w(), h());
        }

        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

        glMatrixMode(GL_PROJECTION);
        glLoadIdentity();
        gluPerspective(60.0, (double)w() / (h() > 0 ? h() : 1), 100.0, 1000000.0);

        glMatrixMode(GL_MODELVIEW);
        glLoadIdentity();
        glTranslatef(0.0f, 0.0f, -cam_dist);
        glRotatef(cam_pitch, 1.0f, 0.0f, 0.0f);
        glRotatef(cam_yaw, 0.0f, 1.0f, 0.0f);
        glTranslatef(-cam_x, 0.0f, -cam_y);

        // Draw a grid for reference
        glColor3f(0.2f,0.2f,0.25f);
        glBegin(GL_LINES);
        for (int i=0;i<=65535;i+=8192) {
            glVertex3f(static_cast<float>(i), 0.0f, 0.0f); glVertex3f(static_cast<float>(i), 0.0f, 65535.0f);
            glVertex3f(0.0f, 0.0f, static_cast<float>(i)); glVertex3f(65535.0f, 0.0f, static_cast<float>(i));
        }
        glEnd();

        // Draw octagons from evaluated data
        {
            std::lock_guard<std::mutex> lock(g_data_mutex);
            // flatten pointer list for quick traversal
            for (size_t idx = 0; idx < g_eval_flat.size(); ++idx) {
                const EvalResult* er = g_eval_flat[idx];
                if (!er) continue;
                // position layout: x determined by bin_id, z determined by index-in-bin (approx)
                float x = static_cast<float>(er->bin_id) / 255.0f * 65535.0f;
                // find index-in-bin for this pointer (linear search but ok for visualization)
                // that index will change as we bubble sort and g_eval_by_bin changes pointers
                int index_in_bin = 0;
                if (er->bin_id >= 0 && er->bin_id < 256) {
                    const auto &vec = g_eval_by_bin[er->bin_id];
                    for (size_t k=0;k<vec.size();++k) {
                        if (&vec[k] == er) { index_in_bin = static_cast<int>(k); break;}
                    }
                }
                float z = static_cast<float>(index_in_bin) * 600.0f; // spacing
                // vertical stacking by bin (so sorted order appears along z)
                float y = static_cast<float>(er->bin_id) / 255.0f * 15000.0f;

                // color derived from bin
                float rr=0,gg=0,bb=0;
                get_color(er->bin_id, rr, gg, bb);
                float base_scale = 0.25f + static_cast<float>(er->bin_id) / 255.0f * 1.75f;
                draw_octagon_at(x, y, z, *er, base_scale, rr, gg, bb);
            }
        }
    }

    int handle(int event) override {
        switch (event) {
            case FL_PUSH:
                last_mx = Fl::event_x();
                last_my = Fl::event_y();
                if (Fl::event_button() == FL_LEFT_MOUSE) drag_rot = true;
                if (Fl::event_button() == FL_RIGHT_MOUSE) drag_pan = true;
                return 1;
            case FL_RELEASE:
                drag_rot = false;
                drag_pan = false;
                return 1;
            case FL_DRAG: {
                int dx = Fl::event_x() - last_mx;
                int dy = Fl::event_y() - last_my;
                last_mx = Fl::event_x();
                last_my = Fl::event_y();

                if (drag_rot) {
                    cam_yaw += dx * 0.5f;
                    cam_pitch += dy * 0.5f;
                }
                if (drag_pan) {
                    float rad = cam_yaw * 3.14159265f / 180.0f;
                    float c = std::cos(rad), s = std::sin(rad);
                    cam_x -= (c * dx - s * dy) * (cam_dist * 0.001f);
                    cam_y -= (s * dx + c * dy) * (cam_dist * 0.001f);
                }
                redraw();
                return 1;
            }
            case FL_MOUSEWHEEL:
                cam_dist -= Fl::event_dy() * (cam_dist * 0.1f);
                if (cam_dist < 100.0f) cam_dist = 100.0f;
                redraw();
                return 1;
            default:
                return Fl_Gl_Window::handle(event);
        }
    }
};

// -----------------------------------------------------------------------------
// UI Logic
// -----------------------------------------------------------------------------
Fl_Check_Browser* browser = nullptr;
LFSRView* gl_view = nullptr;
OctagonSortView* sort_view = nullptr;
Fl_Box* stat_box = nullptr;

// Helper: format stats to label
void update_stats_display() {
    std::string s = "Statistics:\n";
    s += "Visible Bins: " + std::to_string(g_stats.visible_bins) + "\n";
    s += "Total Points: " + std::to_string(g_stats.total_points) + "\n";

    char buf[128];
    std::snprintf(buf, sizeof(buf), "Avg Mask: %.0f\nAvg Seed: %.0f\nDensity: %.6f%%",
                  g_stats.avg_mask, g_stats.avg_seed, g_stats.density);
    s += buf;

    if (stat_box) stat_box->copy_label(s.c_str());
}

// browser callback
void browser_cb(Fl_Widget*, void*) {
    for (int i = 0; i < 256; ++i) {
        bool checked = browser->checked(i + 1);
        if (checked && !g_bins[i].visible) {
            load_bin(i);
            g_bins[i].visible = !g_bins[i].points.empty();
        } else if (!checked && g_bins[i].visible) {
            unload_bin(i);
        }
    }
    update_stats();
    update_stats_display();
    if (gl_view) gl_view->redraw();
}

// select/clear convenience
void select_all_cb(Fl_Widget*, void*) {
    for (int i = 1; i <= 256; ++i) browser->checked(i, 1);
    browser_cb(nullptr, nullptr);
}

void clear_all_cb(Fl_Widget*, void*) {
    for (int i = 1; i <= 256; ++i) browser->checked(i, 0);
    browser_cb(nullptr, nullptr);
}

// Evaluate LFSR for a single Point2D -> EvalResult (period N=65535)
EvalResult evaluate_point(const Point2D &p, int bin_id) {
    EvalResult er;
    er.p = p;
    er.bin_id = bin_id;
    std::fill(er.section_counts.begin(), er.section_counts.end(), 0);
    er.total_on = 0;

    const uint32_t N = 65535u;
    uint16_t lfsr_state = p.seed;
    uint16_t lfsr_mask_current = p.mask;
    uint32_t threshold = static_cast<uint32_t>(p.seed) * 2u; // seed doubling as threshold

    for (uint32_t i = 0; i < N; ++i) {
        int out = (static_cast<uint32_t>(lfsr_state) > threshold) ? 1 : 0;
        if (out) {
            er.total_on++;
            int section = static_cast<int>((i * 8u) / N);
            if (section < 0) section = 0;
            if (section > 7) section = 7;
            er.section_counts[section]++;
        }
        // Advance LFSR state using parity16
        uint16_t feedback = parity16(static_cast<uint16_t>(lfsr_state & lfsr_mask_current));
        lfsr_state = static_cast<uint16_t>((lfsr_state >> 1) | (feedback << 15));
    }

    // compute symmetry score: variance of section counts (lower => more symmetric)
    double mean = 0.0;
    for (int k = 0; k < 8; ++k) mean += static_cast<double>(er.section_counts[k]);
    mean /= 8.0;
    double var = 0.0;
    for (int k = 0; k < 8; ++k) {
        double d = static_cast<double>(er.section_counts[k]) - mean;
        var += d * d;
    }
    var /= 8.0;
    er.symmetry_score = var; // store variance as score
    return er;
}

// Evaluate all loaded bins (recomputes g_eval_by_bin and flat pointers)
void evaluate_all_loaded_bins(Fl_Widget* w = nullptr, void* = nullptr) {
    std::lock_guard<std::mutex> lock(g_data_mutex);
    std::cerr << "[Eval] Starting evaluation of loaded bins...\n";
    // clear previous
    for (auto &v : g_eval_by_bin) v.clear();
    g_eval_flat.clear();

    for (int b = 0; b < 256; ++b) {
        if (!g_bins[b].visible || g_bins[b].points.empty()) continue;
        auto &pts = g_bins[b].points;
        std::vector<EvalResult> results;
        results.reserve(pts.size());
        for (size_t i = 0; i < pts.size(); ++i) {
            EvalResult er = evaluate_point(pts[i], b);
            results.push_back(std::move(er));
            // progress occasionally
            if ((i & 127) == 0) {
                // simple console progress hint
                std::cerr << ".";
            }
        }
        std::cerr << "\n[Eval] Bin " << b << " evaluated (" << results.size() << " points)\n";
        g_eval_by_bin[b] = std::move(results);
    }

    // build flattened pointer array for visualization (pointers into g_eval_by_bin)
    for (int b = 0; b < 256; ++b) {
        for (auto &er : g_eval_by_bin[b]) {
            g_eval_flat.push_back(&er);
        }
    }

    // update stats display in case totals changed
    update_stats();
    update_stats_display();
    if (sort_view) sort_view->redraw();
    if (gl_view) gl_view->redraw();
    std::cerr << "[Eval] Completed.\n";
}

// Bubble sort stepper state (per-bin)
struct BubbleState {
    int bin = 0;
    size_t n = 0;
    size_t i = 0;
    size_t j = 0;
    bool active = false;
} g_bubble_state;

// Timer callback that performs some bubble sort steps per call
void bubble_sort_timer(void*);

// Start bubble sort animation across all evaluated bins (per-bin bubble sort)
void start_bubble_sort(Fl_Widget*, void*) {
    if (g_sorting.load()) return;
    // prepare bubble state: find first bin with items
    {
        std::lock_guard<std::mutex> lock(g_data_mutex);
        g_bubble_state.bin = 0;
        g_bubble_state.active = false;
        for (int b = 0; b < 256; ++b) {
            if (!g_eval_by_bin[b].empty()) {
                g_bubble_state.bin = b;
                g_bubble_state.n = g_eval_by_bin[b].size();
                g_bubble_state.i = 0;
                g_bubble_state.j = 0;
                g_bubble_state.active = true;
                break;
            }
        }
        if (!g_bubble_state.active) {
            std::cerr << "[Sort] Nothing to sort (no evaluated bins)\n";
            return;
        }
    }

    g_sorting = true;
    g_stop_sort = false;
    Fl::add_timeout(0.01, bubble_sort_timer, nullptr);
    std::cerr << "[Sort] Started bubble sort animation.\n";
}

// Stop sort button
void stop_bubble_sort(Fl_Widget*, void*) {
    g_stop_sort = true;
}

// Save button immediate save
void save_now_cb(Fl_Widget*, void*) {
    save_all_bins();
}

// bubble_sort_timer: performs a limited number of comparisons per call to keep UI responsive
void bubble_sort_timer(void*) {
    if (!g_sorting.load()) return;
    if (g_stop_sort.load()) {
        g_sorting = false;
        std::cerr << "[Sort] Stopped by user.\n";
        return;
    }

    bool did_any = false;
    // perform up to K comparisons per timer tick (fine-grain animation)
    const size_t K = 256; // tune as desired
    size_t performed = 0;

    std::lock_guard<std::mutex> lock(g_data_mutex);
    while (performed < K && g_bubble_state.active) {
        auto &vec = g_eval_by_bin[g_bubble_state.bin];
        if (vec.size() < 2) {
            // move to next non-empty bin
            bool found = false;
            for (int b = g_bubble_state.bin + 1; b < 256; ++b) {
                if (!g_eval_by_bin[b].empty()) {
                    g_bubble_state.bin = b;
                    g_bubble_state.n = g_eval_by_bin[b].size();
                    g_bubble_state.i = 0;
                    g_bubble_state.j = 0;
                    found = true;
                    break;
                }
            }
            if (!found) { g_bubble_state.active = false; break; }
            continue;
        }

        // bubble sort indices: outer i from 0..n-2, inner j from 0..n-i-2
        if (g_bubble_state.i >= vec.size() - 1) {
            // finished this bin, move to next bin
            bool found = false;
            for (int b = g_bubble_state.bin + 1; b < 256; ++b) {
                if (!g_eval_by_bin[b].empty()) {
                    g_bubble_state.bin = b;
                    g_bubble_state.n = g_eval_by_bin[b].size();
                    g_bubble_state.i = 0;
                    g_bubble_state.j = 0;
                    found = true;
                    break;
                }
            }
            if (!found) { g_bubble_state.active = false; break; }
            continue;
        }

        size_t n = vec.size();
        if (g_bubble_state.j >= n - g_bubble_state.i - 1) {
            g_bubble_state.i++;
            g_bubble_state.j = 0;
            continue;
        }

        // compare j and j+1
        double a = vec[g_bubble_state.j].symmetry_score;
        double bscore = vec[g_bubble_state.j+1].symmetry_score;
        // want lower variance earlier => swap if a > b
        if (a > bscore) {
            std::swap(vec[g_bubble_state.j], vec[g_bubble_state.j+1]);
            did_any = true;
        }
        g_bubble_state.j++;
        performed++;
    }

    // rebuild flat pointer list for visualization
    g_eval_flat.clear();
    for (int bin = 0; bin < 256; ++bin) {
        for (auto &er : g_eval_by_bin[bin]) g_eval_flat.push_back(&er);
    }

    if (sort_view) sort_view->redraw();
    if (performed > 0) Fl::repeat_timeout(0.01, bubble_sort_timer, nullptr);
    else {
        // finished
        g_sorting = false;
        std::cerr << "[Sort] Completed for all evaluated bins.\n";
    }
}

// Save sorted results back to per-bin files (overwrites file order)
void save_sorted_results_to_files() {
    std::lock_guard<std::mutex> lock(g_data_mutex);
    for (int b = 0; b < 256; ++b) {
        if (g_eval_by_bin[b].empty()) continue;
        // overwrite g_bins[b].points with evaluated ordering
        if (g_bins[b].points.size() != g_eval_by_bin[b].size()) {
            std::cerr << "[SaveSorted] Size mismatch for bin " << b << " skipping\n";
            continue;
        }
        for (size_t i = 0; i < g_eval_by_bin[b].size(); ++i) {
            g_bins[b].points[i] = g_eval_by_bin[b][i].p;
        }
    }
    // write to disk
    save_all_bins();
}

// Register atexit handler to save files on program exit
void on_exit_save() {
    std::cerr << "[Exit] Application exiting: saving sorted bins (if any)...\n";
    save_sorted_results_to_files();
}

// -----------------------------------------------------------------------------
// Main
// -----------------------------------------------------------------------------
int main(int argc, char **argv) {
    std::atexit(on_exit_save);

    Fl_Double_Window* win = new Fl_Double_Window(1280, 720, "LFSR Analytical Visualizer (FLTK/OpenGL)");

    // Create tabs
    Fl_Tabs* tabs = new Fl_Tabs(10, 10, 1260, 700);

    // Tab 1: 3D points (original)
    Fl_Group* grp1 = new Fl_Group(10, 35, 1240, 645, "Point Cloud");
    grp1->begin();
    gl_view = new LFSRView(10, 35, 980, 660);
    grp1->end();

    // Tab 2: Octagon sorting visualization
    Fl_Group* grp2 = new Fl_Group(10, 35, 1240, 645, "Octagon Sorting");
    grp2->begin();
    sort_view = new OctagonSortView(10, 35, 980, 660);
    grp2->end();

    tabs->end();

    // Right: Controls group (static on right)
    Fl_Group* controls = new Fl_Group(1000, 10, 270, 700);
    controls->begin();

    // Bin selector
    browser = new Fl_Check_Browser(1000, 10, 270, 320, "PWM Bins (0x00 - 0xFF)");
    for (int i = 0; i < 256; ++i) {
        char buf[32];
        std::snprintf(buf, sizeof(buf), "Bin 0x%02X (%d)", i, i);
        browser->add(buf);
    }
    browser->callback(browser_cb);
    browser->when(FL_WHEN_CHANGED);

    Fl_Button* btn_all = new Fl_Button(1000, 340, 130, 25, "Select All");
    btn_all->callback(select_all_cb);

    Fl_Button* btn_none = new Fl_Button(1140, 340, 130, 25, "Clear");
    btn_none->callback(clear_all_cb);

    // Evaluate / Sort controls
    Fl_Button* btn_eval = new Fl_Button(1000, 370, 130, 30, "Evaluate");
    btn_eval->callback((Fl_Callback*)[](Fl_Widget*, void*) { evaluate_all_loaded_bins(); });

    Fl_Button* btn_sort = new Fl_Button(1140, 370, 130, 30, "Sort (Bubble)");
    btn_sort->callback(start_bubble_sort);

    Fl_Button* btn_stop = new Fl_Button(1000, 410, 130, 30, "Stop Sort");
    btn_stop->callback(stop_bubble_sort);

    Fl_Button* btn_save = new Fl_Button(1140, 410, 130, 30, "Save");
    btn_save->callback(save_now_cb);

    // Statistics Panel
    Fl_Box* stat_panel = new Fl_Box(1000, 450, 270, 200);
    stat_panel->box(FL_DOWN_BOX);
    stat_panel->color(fl_rgb_color(220, 220, 220));

    stat_box = new Fl_Box(1010, 460, 250, 180, "Select bins to view stats...");
    stat_box->align(FL_ALIGN_TOP_LEFT | FL_ALIGN_INSIDE);
    stat_box->labelfont(FL_COURIER);

    controls->end();

    win->end();
    win->resizable(gl_view);
    win->show(argc, argv);

    // initial stats display
    update_stats();
    update_stats_display();

    return Fl::run();
}
